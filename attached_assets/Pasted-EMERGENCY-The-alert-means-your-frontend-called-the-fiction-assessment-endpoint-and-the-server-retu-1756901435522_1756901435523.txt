EMERGENCY: The alert means your frontend called the fiction assessment endpoint, and the server returned HTTP 500 (Internal Server Error). The UI is just surfacing that 500. The scoring edits likely broke the route or service so it now throws before returning JSON.

Do this exactly:

Find the route and wire-up

In shell:
grep -Rn "fiction" server | sed -n '1,50p'

Open the file that handles the endpoint (use this path; if missing, create it): server/routes/fiction.ts

Ensure itâ€™s registered in server/routes.ts:

import fictionRoutes from "./routes/fiction";
app.use("/api/assess/fiction", fictionRoutes);


Replace the route with a safe, non-breaking handler

Put this in server/routes/fiction.ts:

import { Router } from "express";
import { assessFiction } from "../services/assessments/fiction";
export default Router().post("/", async (req, res) => {
  try {
    const { text, preview } = req.body ?? {};
    if (!text || typeof text !== "string") {
      return res.status(400).json({ error: "MISSING_TEXT" });
    }
    const out = await assessFiction({ text, provider: "zhi1", preview: !!preview });
    return res.status(200).json(out);
  } catch (err: any) {
    console.error("[FICTION] FAIL:", err);
    return res.status(500).json({
      error: "FICTION_ASSESSMENT_FAILED",
      detail: err?.message ?? String(err),
    });
  }
});


Make the service never throw on model/provider errors

Open/create server/services/assessments/fiction.ts and replace its export with:

type Args = { text: string; provider: "zhi1" | string; preview: boolean };
export async function assessFiction({ text, provider, preview }: Args) {
  try {
    // TODO: keep existing scoring logic; DO NOT delete it.
    // Call into your model; if it fails, catch and degrade.
    const result = await globalThis.modelRouter.assessFiction({ text, provider, preview });
    // Expect a uniform shape:
    // { scores: {...}, summary: string, quotes: string[] }
    if (!result || typeof result !== "object") {
      return fallback("EMPTY_RESULT");
    }
    return sanitize(result);
  } catch (e: any) {
    console.warn("[FICTION] provider error:", e?.message ?? e);
    return fallback(e?.message ?? "PROVIDER_ERROR");
  }
}
function sanitize(r: any) {
  return {
    scores: r.scores ?? {},
    summary: typeof r.summary === "string" ? r.summary : "",
    quotes: Array.isArray(r.quotes) ? r.quotes : [],
  };
}
function fallback(reason: string) {
  return {
    scores: {},
    summary: `Fiction preview unavailable (${reason}).`,
    quotes: [],
  };
}


Do NOT modify any scoring math now. Goal: return a valid JSON shape even if the model fails, so the UI stops throwing alerts.

Add a quick health probe so we can test without the model

Append to server/routes/fiction.ts:

import health from "express";


(already imported via Router)
Then add above the POST:

export default Router()
  .get("/health", (_req, res) => res.json({ ok: true }))
  .post("/", async (req, res) => { /* as above */ });


Restart and test from shell

Restart your dev server.

From shell, hit health:
curl -sS http://localhost:3000/api/assess/fiction/health

Then post a minimal body (no model call should crash):
curl -sS -X POST http://localhost:3000/api/assess/fiction -H "Content-Type: application/json" -d '{"text":"test","preview":true}'

Expected: 200 with JSON (either real result or the fallback). If you still see 500, the error is outside this route (body-parser, auth, or modelRouter wiring). Then:

Common 500 killers to fix immediately

Missing body parser: in server/index.ts ensure
app.use(express.json({ limit: "1mb" }));

Broken import path after scoring edits: confirm the exact path ../services/assessments/fiction exists.

Unhandled promise rejections: ensure every await in the fiction path is inside the try/catch above.

Env key missing for zhi1: if the service needs ZHI1_API_KEY, guard the call and use the fallback when absent.

Logging you must keep (do not remove)

The console.error("[FICTION] FAIL:", err) line.

A single console.warn in the service for provider failures.

Bottom line: Return a valid JSON object no matter what. The UI error you saw is a plain 500 bubbling up; the patches above force a 200 with fallback when the provider/scoring breaks, so the feature renders instead of dying.